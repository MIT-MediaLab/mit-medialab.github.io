<!DOCTYPE html>
<html lang="en" >
<head>
    <title>Trackbot | A 3D Tracking Visualization</title>
    <link rel="stylesheet" type="text/css" href="./style.css" />
    <meta name="viewport" content="minimum-scale=1, initial-scale=1, width=device-width">
    <!-- <script src="https://raw.github.com/sole/tween.js/master/build/tween.min.js"></script> -->
    <!-- <script src="./js/three.min.js" charset="utf-8"></script> -->
    <script src="https://d3js.org/d3.v3.min.js" charset="utf-8"></script>
</head>
<body>

<canvas id="c"></canvas>
 <!-- 1. create spans for displaying camera position and lookAt vectors -->
 <div id="camera-vectors">
    <span>Free Camera Vectors</span><br>
    <span id="position"></span><br>
    <span id="lookingAt"></span>
  </div>

<script src='https://cdnjs.cloudflare.com/ajax/libs/three.js/98/three.min.js'></script>
<!-- <script src="./js/three.min.js" charset="utf-8"></script>  -->


<script type="importmap">
    {
        "imports": {
            "three": "https://threejs.org/build/three.module.js",
            "three/addons/": "https://threejs.org/examples/jsm/"
        }
    }
</script>

<script type="module">

// JS code
import * as THREE from 'three';
import {OrbitControls} from 'three/addons/controls/OrbitControls.js';
import {OBJLoader} from 'three/addons/loaders/OBJLoader.js';
import {MTLLoader} from 'three/addons/loaders/MTLLoader.js';
import {GLTFLoader} from 'three/addons/loaders/GLTFLoader.js';
// import {FlyControls} from 'https://raw.githubusercontent.com/mrdoob/three.js/master/examples/jsm/controls/FlyControls.js';

// import { addWallLighting, addRoom } from './common';
let camera, scene, canvas, controls, renderer
// 3. define cameraDirection and span variables
let cameraDirection = new THREE.Vector3()
let camPositionSpan, camLookAtSpan


function init() {
    scene = new THREE.Scene();
    canvas = document.querySelector("#canvas");
    // 4. set the spans with the queried HTML DOM elements
    camPositionSpan = document.querySelector("#position");
    camLookAtSpan = document.querySelector("#lookingAt");
    // Set up the renderer
    renderer = new THREE.WebGLRenderer({canvas});
    renderer.setSize( window.innerWidth, window.innerHeight );
    // Set up camera
    camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 500);
    camera.position.set(0, 75, 160);
    // Initiate FlyControls with various params
    controls = new FlyControls( camera, renderer.domElement );
    controls.movementSpeed = 100;
    controls.rollSpeed = Math.PI / 24;
    controls.autoForward = false;
    controls.dragToLook = true;
    // set up a basic room scene
    // addWallLighting(scene);
    // addRoom(scene);
  }
  // Animate the scene
  function animate() {
    renderer.render( scene, camera );
    // update controls with a small step value to "power its engines"
    controls.update(0.01)
    // 5. calculate and display the vector values on screen
    // this copies the camera's unit vector direction to cameraDirection
    camera.getWorldDirection(cameraDirection)
    // scale the unit vector up to get a more intuitive value
    cameraDirection.set(cameraDirection.x * 100, cameraDirection.y * 100, cameraDirection.z * 100)
    // update the onscreen spans with the camera's position and lookAt vectors
    camPositionSpan.innerHTML = `Position: (${camera.position.x.toFixed(1)}, ${camera.position.y.toFixed(1)}, ${camera.position.z.toFixed(1)})`
    camLookAtSpan.innerHTML = `LookAt: (${(camera.position.x + cameraDirection.x).toFixed(1)}, ${(camera.position.y + cameraDirection.y).toFixed(1)}, ${(camera.position.z + cameraDirection.z).toFixed(1)})`
    requestAnimationFrame( animate );
  };

function main() {
  const canvas = document.querySelector('#c');
  const renderer = new THREE.WebGLRenderer({canvas});
  renderer.outputEncoding = THREE.sRGBEncoding;

  const fov = 45;
  const aspect = 2;  // the canvas default
  const near = 0.1;
  const far = 100;
//   const camera = new THREE.PerspectiveCamera(fov, aspect, near, far);
//   camera.position.set(0, 10, 20);

  const camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 0.1, 100 );
  camera.position.set( 0, 10, 20 );

  const controls = new OrbitControls(camera, canvas);
  controls.target.set(0, 5, 0);
  controls.update();

  const scene = new THREE.Scene();
  scene.background = new THREE.Color('black');

  {
    const planeSize = 40;

    const loader = new THREE.TextureLoader();
    const texture = loader.load('./models/textured_0_Up6yJWLK.jpg');
    texture.encoding = THREE.sRGBEncoding;
    texture.wrapS = THREE.RepeatWrapping;
    texture.wrapT = THREE.RepeatWrapping;
    texture.magFilter = THREE.NearestFilter;
    const repeats = planeSize / 2;
    texture.repeat.set(repeats, repeats);

    const planeGeo = new THREE.PlaneGeometry(planeSize, planeSize);
    const planeMat = new THREE.MeshPhongMaterial({
      map: texture,
      side: THREE.DoubleSide,
    });
    const mesh = new THREE.Mesh(planeGeo, planeMat);
    mesh.rotation.x = Math.PI * -.5;
    // scene.add(mesh);
  }

  { //axis helper
    const axesHelper = new THREE.AxesHelper( 5 );
    scene.add( axesHelper );
  }

  /////grid
  {
    var grid = new THREE.GridHelper(10, 10);
    scene.add(grid);
  var gridXZ = new THREE.GridHelper(10, 10);
	//gridXZ.setColors( new THREE.Color(0x006600), new THREE.Color(0x006600) );
	gridXZ.position.set(1,0,1 );
	scene.add(gridXZ);
	
	var gridXY = new THREE.GridHelper(10, 10);
	gridXY.position.set( 1,1,0 );
	gridXY.rotation.x = Math.PI/2;
	// gridXY.setColors( new THREE.Color(0x000066), new THREE.Color(0x000066) );
	scene.add(gridXY);

	var gridYZ = new THREE.GridHelper(10, 10);
	gridYZ.position.set( 0,1,1 );
	gridYZ.rotation.z = Math.PI/2;
	// gridYZ.setColors( new THREE.Color(0x660000), new THREE.Color(0x660000) );

  scene.add(gridYZ);
  }

  ///// adding points

  {
    const pointGeometry = new THREE.BufferGeometry();
   // create data as Float32Array

    const ExpectedData = new Float32Array([
      
3.65, 1.3, 1.38,
3.65, 0.39, 1.84,
3.65, 0.2, 1.05,
2.4, 2.5, 1.26,
2.25, 2.5, 1.26,
2.35, 0.26, 1.22,
1.25, 0.6, 1.85,
1.25, 0.2, 1.52,
1.62, 1.54, 1.87,
1.57, 1.54, 1.47,
1.2, 1.54, 1.47,
1.57, 1.54, 1.17,
1.33, 1.54, 1.2,
-0.15, 1.95, 1.35,
-0.15, 2.1, 1.35,
0.0, 0.7, 1.87,
-0.5, 0.2, 1.52,
3.65, 1.3, 1.38,
3.65, 0.39, 1.84,
3.65, 0.2, 1.05,
2.4, 2.5, 1.26,
2.25, 2.5, 1.26,
2.35, 0.26, 1.22,
1.25, 0.6, 1.85,
1.25, 0.2, 1.52,
1.62, 1.54, 1.87,
1.57, 1.54, 1.47,
1.2, 1.54, 1.47,
1.57, 1.54, 1.17,
1.33, 1.54, 1.2,
-0.15, 1.95, 1.35,
-0.15, 2.1, 1.35,
0.0, 0.7, 1.87,
-0.5, 0.2, 1.52,
0.0, 0.7, 1.87,
-0.5, 0.2, 1.52,
3.65, 1.3, 1.38,
3.65, 0.39, 1.84,
3.65, 0.2, 1.05,
2.4, 2.5, 1.26,
2.25, 2.5, 1.26,
2.35, 0.26, 1.22,
1.25, 0.6, 1.85,
1.25, 0.2, 1.52,
1.62, 1.54, 1.87,
1.57, 1.54, 1.47,
1.2, 1.54, 1.47,
1.57, 1.54, 1.17,
1.33, 1.54, 1.2,
-0.15, 1.95, 1.35,
-0.15, 2.1, 1.35,
0.0, 0.7, 1.87,
-0.5, 0.2, 1.52,
3.65, 1.3, 1.38,
3.65, 0.39, 1.84,
3.65, 0.2, 1.05,
2.4, 2.5, 1.26,
2.25, 2.5, 1.26,
2.35, 0.26, 1.22,
1.25, 0.6, 1.85,
1.25, 0.2, 1.52,
1.62, 1.54, 1.87,
1.57, 1.54, 1.47,
1.2, 1.54, 1.47,
1.57, 1.54, 1.17,
1.33, 1.54, 1.2,
-0.15, 1.95, 1.35,
-0.15, 2.1, 1.35,
0.0, 0.7, 1.87,
-0.5, 0.2, 1.52,
-0.5, 0.2, 1.52,
3.56, 1.3, 1.38,
3.61, 0.39, 1.84,
3.61, 0.23, 1.05,
2.55, 0.26, 1.22,
2.35, 0.26, 1.22,
2.25, 2.5, 1.26,
2.1, 2.5, 1.26,
1.2, 1.45, 1.89,
1.55, 1.45, 1.85,
1.34, 1.45, 1.54,
1.65, 1.5, 1.54,
1.27, 1.45, 1.17,
1.55, 1.45, 1.17,
1.1, 0.55, 1.77,
1.5, 0.55, 1.77,
1.1, 0.55, 1.42,
-0.15, 1.95, 1.35,
0.0, 0.7, 1.87,
-0.5, 0.2, 1.52,
3.56, 1.3, 1.38,
3.61, 0.39, 1.84,
3.61, 0.23, 1.05,
3.61, -0.19, 1.1,
2.55, 0.26, 1.22,
2.35, 0.26, 1.22,
2.1, 0.26, 1.22,
2.4, 2.5, 1.26,
2.25, 2.5, 1.26,
2.1, 2.5, 1.26,

    ])

    var data = new Float32Array( [
1.4, 1.2000000000000002, 1.2,
1.6, 0.6, 2.1999999999999997,
1.6, 0.4, 1.4,
0.4, 2.4000000000000004, 1.4,
0.2, 2.6, 1.4,
0.4, 0.6, 1.2,
-1.2000000000000002, 0.6, 1.9999999999999998,
-1.2000000000000002, 0.20000000000000007, 1.5999999999999999,
-1.6, 1.6, 2.1999999999999997,
-1.6, 1.6, 1.5999999999999999,
-1.4, 1.4, 1.5999999999999999,
-1.6, 1.4, 1.2,
-1.2000000000000002, 1.4, 1.5999999999999999,
-1.1102230246251565e-16, 2.2, 1.2,
-2.19999999999999996, 1.2000000000000002, 1.9999999999999998,
-2.39999999999999997, 0.6, 2.1999999999999997,
-2.6, 0.20000000000000007, 1.9999999999999998,
3.4, 1.2000000000000002, 1.2,
3.6, 0.6, 2.1999999999999997,
3.6, 0.4, 1.4,
2.4, 2.4000000000000004, 1.4,
2.2, 2.6, 1.4,
2.4, 0.6, 1.2,
1.2000000000000002, 0.6, 1.9999999999999998,
1.2000000000000002, 0.20000000000000007, 1.5999999999999999,
1.6, 1.6, 2.1999999999999997,
1.6, 1.6, 1.5999999999999999,
1.4, 1.4, 1.5999999999999999,
1.6, 1.4, 1.2,
1.2000000000000002, 1.4, 1.5999999999999999,
1.1102230246251565e-16, 2.2, 1.2,
-0.19999999999999996, 1.2000000000000002, 1.9999999999999998,
-0.39999999999999997, 0.6, 2.1999999999999997,
-0.6, 0.20000000000000007, 1.9999999999999998,
-0.39999999999999997, 0.6, 2.1999999999999997,
-0.6, 0.20000000000000007, 1.9999999999999998,
3.4, 1.2000000000000002, 1.2,
3.6, 0.6, 2.1999999999999997,
3.6, 0.4, 1.4,
2.4, 2.4000000000000004, 1.4,
2.2, 2.6, 1.4,
2.4, 0.6, 1.2,
1.2000000000000002, 0.6, 1.9999999999999998,
1.2000000000000002, 0.20000000000000007, 1.5999999999999999,
1.6, 1.6, 2.1999999999999997,
1.6, 1.6, 1.5999999999999999,
1.4, 1.4, 1.5999999999999999,
1.6, 1.4, 1.2,
1.2000000000000002, 1.4, 1.5999999999999999,
1.1102230246251565e-16, 2.2, 1.2,
-0.19999999999999996, 1.2000000000000002, 1.9999999999999998,
-0.39999999999999997, 0.6, 2.1999999999999997,
-0.6, 0.20000000000000007, 1.9999999999999998,
3.4, 1.2000000000000002, 1.2,
3.6, 0.6, 2.1999999999999997,
3.6, 0.4, 1.4,
2.4, 2.4000000000000004, 1.4,
2.2, 2.6, 1.4,
2.4, 0.6, 1.2,
1.2000000000000002, 0.6, 1.9999999999999998,
1.2000000000000002, 0.20000000000000007, 1.5999999999999999,
1.6, 1.6, 2.1999999999999997,
1.6, 1.6, 1.5999999999999999,
1.4, 1.4, 1.5999999999999999,
1.6, 1.4, 1.2,
1.2000000000000002, 1.4, 1.5999999999999999,
1.1102230246251565e-16, 2.2, 1.2,
-0.19999999999999996, 1.2000000000000002, 1.9999999999999998,
-0.39999999999999997, 0.6, 2.1999999999999997,
-0.6, 0.20000000000000007, 1.9999999999999998,
-0.6, 0.20000000000000007, 1.9999999999999998,
3.2, 1.2000000000000002, 1.2,
3.6, 0.4, 1.7999999999999998,
3.6, 0.20000000000000007, 1.4,
2.4, 0.6, 1.0,
2.2, 0.20000000000000007, 1.5999999999999999,
2.4, 1.4, 1.5999999999999999,
2.2, 1.4, 1.4,
1.2000000000000002, 1.4, 2.1999999999999997,
1.6, 1.4, 2.1999999999999997,
1.4, 1.4, 1.7999999999999998,
1.6, 1.4, 1.4,
1.2000000000000002, 1.6, 1.5999999999999999,
1.6, 1.6, 1.5999999999999999,
1.2000000000000002, 1.4, 1.0,
1.2000000000000002, 1.6, 1.2,
0.20000000000000007, 0.6, 1.7999999999999998,
-0.39999999999999997, 2.0000000000000004, 0.8,
0.20000000000000007, 0.8000000000000002, 1.9999999999999998,
-0.6, 0.20000000000000007, 1.9999999999999998,
3.2, 1.2000000000000002, 1.2,
3.4, 0.4, 1.5999999999999999,
3.6, 0.20000000000000007, 1.4,
3.6, 0.0, 1.4,
2.4, 0.6, 1.0,
2.2, 0.20000000000000007, 1.5999999999999999,
2.2, 1.4, 0.8,
2.4, 2.6, 1.4,
2.4, 2.6, 1.5999999999999999,
2.2, 2.0000000000000004, 1.5999999999999999,
    ]);



    var newData = new Float32Array( [
1.4, 1.8, -3.2000000000000002,
1.6, 0.81, -2.6,
1.6, 1.6, -2.4,
0.4, 1.6, -4.4000000000000004,
0.2, 1.6, -4.6,
0.4, 1.8, -2.6,
-1.2000000000000002, 2.1, -2.6,
-1.2000000000000002, 1.41, -2.20000000000000007,
-1.6, 1.81, -3.6, 
-1.6, 1.41, -3.6,
-1.4, 1.41, -3.4,
-1.6, 1.8, -3.4, 
-1.2000000000000002, 1.41, -3.4, 
-1.1102230246251565e-16, 1.8, -4.2, 
-2.19999999999999996, 1.01, -3.2000000000000002, 
-2.39999999999999997, 0.81, -2.6, 
-2.6, 1.01, -2.20000000000000007, 
1.4, 1.2000000000000002, -3.2,
1.6, 0.81, -2.6,
1.6, 1.6, -2.4,
]);



    //update logic mapping:
    // mapped=[]
    // const mapped_data = data.filter( item => {
    //   if(temp.length==0)
    //   if(item%3==0){
    //     mapped.push(item)
    //   }else if (item%2==0){
    //     mapped.push(item)
    //   }else {
    //     mapped.push(item)
    //   }      
    // });

    // data = mapped
    data = newData;
    // create new instance of BufferAttribute with Float3sArray and set as 'position'
    pointGeometry.setAttribute('position', new THREE.BufferAttribute( data.slice(0, 60), 3));
    // can now call methods like translate, center, rotateX, ect
    pointGeometry.center();
    //-------- ----------
    // POINTS
    //-------- ----------
    const geoPoints = new THREE.Points(pointGeometry, new THREE.PointsMaterial({size: 0.3, color:0xff0000  }));
    camera.lookAt(geoPoints.position);
    scene.add(geoPoints);

    //-------- ----------
    // Add events: https://stackoverflow.com/questions/23723937/how-to-click-an-object-in-three-js
    //-------- ----------
    
    
  }

  ////////////// add axis helper
  {
    var axesHelper = new THREE.AxesHelper( 5 );
    scene.add( axesHelper );
  }
  //////mapping points

  // {

  //   function createTextCanvas(text, color, font, size) {
  //       size = size || 16;
  //       var canvas = document.createElement('canvas');
  //       var ctx = canvas.getContext('2d');
  //       var fontStr = (size + 'px ') + (font || 'Arial');
  //       ctx.font = fontStr;
  //       var w = ctx.measureText(text).width;
  //       var h = Math.ceil(size);
  //       canvas.width = w;
  //       canvas.height = h;
  //       ctx.font = fontStr;
  //       ctx.fillStyle = color || 'black';
  //       ctx.fillText(text, 0, Math.ceil(size * 0.8));
  //       return canvas;
  //   }

  //   function createText2D(text, color, font, size, segW, segH) {
  //       var canvas = createTextCanvas(text, color, font, size);
  //       var plane = new THREE.PlaneGeometry(canvas.width, canvas.height, segW, segH);
  //       var tex = new THREE.Texture(canvas);
  //       tex.needsUpdate = true;
  //       var planeMat = new THREE.MeshBasicMaterial({
  //           map: tex,
  //           color: 0xffffff,
  //           transparent: true
  //       });
  //       var mesh = new THREE.Mesh(plane, planeMat);
  //       mesh.scale.set(0.5, 0.5, 0.5);
  //       mesh.doubleSided = true;
  //       return mesh;
  //   }

  //   var scatterPlot = new THREE.Object3D();
  //   scene.add(scatterPlot);

  //   scatterPlot.rotation.y = 0;

  //   function v(x, y, z) {
  //       return new THREE.Vector3(x, y, z);
  //   }

  //   var unfiltered = [],
  //       lowPass = [],
  //       highPass = [];

  //   var format = d3.format("+.3f");

  //   var data = d3.csv("./data/sampledata.csv", function (d) {
        
  //       d.forEach(function (d,i) {
  //           unfiltered[i] = {
  //               x: + JSON.parse(d.measured_pos)[0],
  //               y: + JSON.parse(d.measured_pos)[1],
  //               z: + JSON.parse(d.measured_pos)[2]
  //           };
  //           lowPass[i] = {
  //               x: +d.lp_x,
  //               y: +d.lp_y,
  //               z: +d.lp_z
  //           };
  //           highPass[i] = {
  //               x: +d.hp_x,
  //               y: +d.hp_y,
  //               z: +d.hp_z
  //           }
  //       })

  //   var xExent = d3.extent(unfiltered, function (d) {return d.x; }),
  //       yExent = d3.extent(unfiltered, function (d) {return d.y; }),
  //       zExent = d3.extent(unfiltered, function (d) {return d.z; });

  //   var vpts = {
  //       xMax: xExent[1],
  //       xCen: (xExent[1] + xExent[0]) / 2,
  //       xMin: xExent[0],
  //       yMax: yExent[1],
  //       yCen: (yExent[1] + yExent[0]) / 2,
  //       yMin: yExent[0],
  //       zMax: zExent[1],
  //       zCen: (zExent[1] + zExent[0]) / 2,
  //       zMin: zExent[0]
  //   }

  //   var colour = d3.scale.category20c();

  //   var xScale = d3.scale.linear()
  //                 .domain(xExent)
  //                 .range([-50,50]);
  //   var yScale = d3.scale.linear()
  //                 .domain(yExent)
  //                 .range([-50,50]);                  
  //   var zScale = d3.scale.linear()
  //                 .domain(zExent)
  //                 .range([-50,50]);


  //   const lineGeo_points = []
  //   lineGeo_points.push(
  //       v(xScale(vpts.xMin), yScale(vpts.yCen), zScale(vpts.zCen)), v(xScale(vpts.xMax), yScale(vpts.yCen), zScale(vpts.zCen)),
  //       v(xScale(vpts.xCen), yScale(vpts.yMin), zScale(vpts.zCen)), v(xScale(vpts.xCen), yScale(vpts.yMax), zScale(vpts.zCen)),
  //       v(xScale(vpts.xCen), yScale(vpts.yCen), zScale(vpts.zMax)), v(xScale(vpts.xCen), yScale(vpts.yCen), zScale(vpts.zMin)),

  //       v(xScale(vpts.xMin), yScale(vpts.yMax), zScale(vpts.zMin)), v(xScale(vpts.xMax), yScale(vpts.yMax), zScale(vpts.zMin)),
  //       v(xScale(vpts.xMin), yScale(vpts.yMin), zScale(vpts.zMin)), v(xScale(vpts.xMax), yScale(vpts.yMin), zScale(vpts.zMin)),
  //       v(xScale(vpts.xMin), yScale(vpts.yMax), zScale(vpts.zMax)), v(xScale(vpts.xMax), yScale(vpts.yMax), zScale(vpts.zMax)),
  //       v(xScale(vpts.xMin), yScale(vpts.yMin), zScale(vpts.zMax)), v(xScale(vpts.xMax), yScale(vpts.yMin), zScale(vpts.zMax)),

  //       v(xScale(vpts.xMin), yScale(vpts.yCen), zScale(vpts.zMax)), v(xScale(vpts.xMax), yScale(vpts.yCen), zScale(vpts.zMax)),
  //       v(xScale(vpts.xMin), yScale(vpts.yCen), zScale(vpts.zMin)), v(xScale(vpts.xMax), yScale(vpts.yCen), zScale(vpts.zMin)),
  //       v(xScale(vpts.xMin), yScale(vpts.yMax), zScale(vpts.zCen)), v(xScale(vpts.xMax), yScale(vpts.yMax), zScale(vpts.zCen)),
  //       v(xScale(vpts.xMin), yScale(vpts.yMin), zScale(vpts.zCen)), v(xScale(vpts.xMax), yScale(vpts.yMin), zScale(vpts.zCen)),

  //       v(xScale(vpts.xMax), yScale(vpts.yMin), zScale(vpts.zMin)), v(xScale(vpts.xMax), yScale(vpts.yMax), zScale(vpts.zMin)),
  //       v(xScale(vpts.xMin), yScale(vpts.yMin), zScale(vpts.zMin)), v(xScale(vpts.xMin), yScale(vpts.yMax), zScale(vpts.zMin)),
  //       v(xScale(vpts.xMax), yScale(vpts.yMin), zScale(vpts.zMax)), v(xScale(vpts.xMax), yScale(vpts.yMax), zScale(vpts.zMax)),
  //       v(xScale(vpts.xMin), yScale(vpts.yMin), zScale(vpts.zMax)), v(xScale(vpts.xMin), yScale(vpts.yMax), zScale(vpts.zMax)),

  //       v(xScale(vpts.xCen), yScale(vpts.yMin), zScale(vpts.zMax)), v(xScale(vpts.xCen), yScale(vpts.yMax), zScale(vpts.zMax)),
  //       v(xScale(vpts.xCen), yScale(vpts.yMin), zScale(vpts.zMin)), v(xScale(vpts.xCen), yScale(vpts.yMax), zScale(vpts.zMin)),
  //       v(xScale(vpts.xMax), yScale(vpts.yMin), zScale(vpts.zCen)), v(xScale(vpts.xMax), yScale(vpts.yMax), zScale(vpts.zCen)),
  //       v(xScale(vpts.xMin), yScale(vpts.yMin), zScale(vpts.zCen)), v(xScale(vpts.xMin), yScale(vpts.yMax), zScale(vpts.zCen)),

  //       v(xScale(vpts.xMax), yScale(vpts.yMax), zScale(vpts.zMin)), v(xScale(vpts.xMax), yScale(vpts.yMax), zScale(vpts.zMax)),
  //       v(xScale(vpts.xMax), yScale(vpts.yMin), zScale(vpts.zMin)), v(xScale(vpts.xMax), yScale(vpts.yMin), zScale(vpts.zMax)),
  //       v(xScale(vpts.xMin), yScale(vpts.yMax), zScale(vpts.zMin)), v(xScale(vpts.xMin), yScale(vpts.yMax), zScale(vpts.zMax)),
  //       v(xScale(vpts.xMin), yScale(vpts.yMin), zScale(vpts.zMin)), v(xScale(vpts.xMin), yScale(vpts.yMin), zScale(vpts.zMax)),

  //       v(xScale(vpts.xMin), yScale(vpts.yCen), zScale(vpts.zMin)), v(xScale(vpts.xMin), yScale(vpts.yCen), zScale(vpts.zMax)),
  //       v(xScale(vpts.xMax), yScale(vpts.yCen), zScale(vpts.zMin)), v(xScale(vpts.xMax), yScale(vpts.yCen), zScale(vpts.zMax)),
  //       v(xScale(vpts.xCen), yScale(vpts.yMax), zScale(vpts.zMin)), v(xScale(vpts.xCen), yScale(vpts.yMax), zScale(vpts.zMin)),
  //       v(xScale(vpts.xCen), yScale(vpts.yMin), zScale(vpts.zMin)), v(xScale(vpts.xCen), yScale(vpts.yMin), zScale(vpts.zMax))

  //   );

  //   let lineGeo = new THREE.BufferGeometry().setFromPoints( lineGeo_points )

  //   var lineMat = new THREE.LineBasicMaterial({
  //       color: 0x000000,
  //       lineWidth: 1
  //   });
  //   var line = new THREE.Line(lineGeo, lineMat);
  //   line.type = THREE.Lines;
  //   scatterPlot.add(line);

  //   var titleX = createText2D('-X');

  //   titleX.position.x = xScale(vpts.xMin) - 12,
  //   titleX.position.y = 5;
  //   scatterPlot.add(titleX);

  //   var valueX = createText2D(format(xExent[0]));
  //   valueX.position.x = xScale(vpts.xMin) - 12,
  //   valueX.position.y = -5;
  //   scatterPlot.add(valueX);

  //   var titleX = createText2D('X');
  //   titleX.position.x = xScale(vpts.xMax) + 12;
  //   titleX.position.y = 5;
  //   scatterPlot.add(titleX);

  //   var valueX = createText2D(format(xExent[1]));
  //   valueX.position.x = xScale(vpts.xMax) + 12,
  //   valueX.position.y = -5;
  //   scatterPlot.add(valueX);

  //   var titleY = createText2D('-Y');
  //   titleY.position.y = yScale(vpts.yMin) - 5;
  //   scatterPlot.add(titleY);

  //   var valueY = createText2D(format(yExent[0]));
  //   valueY.position.y = yScale(vpts.yMin) - 15,
  //   scatterPlot.add(valueY);

  //   var titleY = createText2D('Y');
  //   titleY.position.y = yScale(vpts.yMax) + 15;
  //   scatterPlot.add(titleY);

  //   var valueY = createText2D(format(yExent[1]));
  //   valueY.position.y = yScale(vpts.yMax) + 5,
  //   scatterPlot.add(valueY);

  //   var titleZ = createText2D('-Z ' + format(zExent[0]));
  //   titleZ.position.z = zScale(vpts.zMin) + 2;
  //   scatterPlot.add(titleZ);

  //   var titleZ = createText2D('Z ' + format(zExent[1]));
  //   titleZ.position.z = zScale(vpts.zMax) + 2;
  //   scatterPlot.add(titleZ);

  //   var mat = new THREE.PointsMaterial({
  //       vertexColors: true,
  //       size: 10
  //   });

  //   var pointCount = unfiltered.length;
  //   var pointGeo_points = []
  //   for (var i = 0; i < pointCount; i ++) {
  //       var x = xScale(unfiltered[i].x);
  //       var y = yScale(unfiltered[i].y);
  //       var z = zScale(unfiltered[i].z);

  //       pointGeo_points.push(new THREE.Vector3(x, y, z));
  //       console.log(pointGeo_points);
  //       //pointGeo.vertices[i].angle = Math.atan2(z, x);
  //       //pointGeo.vertices[i].radius = Math.sqrt(x * x + z * z);
  //       //pointGeo.vertices[i].speed = (z / 100) * (x / 100);

  //       // pointGeo.colors.push(new THREE.Color().setRGB(
  //       //   hexToRgb(colour(i)).r / 255, hexToRgb(colour(i)).g / 255, hexToRgb(colour(i)).b / 255 
  //       // ));

  //   }

  //   var pointGeo = new THREE.BufferGeometry().setFromPoints( pointGeo_points )

  //   var pointMat = new THREE.PointsMaterial({
  //       color: 0x111111
  //   });

  //   var points = new THREE.ParticleSystem(pointGeo, pointMat);
  //   scatterPlot.add(points);
    
  // })

  // }

  {
    const skyColor = 0xB1E1FF;  // light blue
    const groundColor = 0xB97A20;  // brownish orange
    const intensity = 1;
    const light = new THREE.HemisphereLight(skyColor, groundColor, intensity);
    scene.add(light);
  }

  {
    const color = 0xFFFFFF;
    const intensity = 1;
    const light = new THREE.DirectionalLight(color, intensity);
    light.position.set(5, 10, 2);
    scene.add(light);
    scene.add(light.target);
  }

  // { // load obj
  //   const mtlLoader = new MTLLoader();
  //   mtlLoader.load('./models/textured.mtl', (mtl) => {
  //     mtl.preload();
  //     const objLoader = new OBJLoader();
  //     objLoader.setMaterials(mtl);
  //     objLoader.load('./models/textured.obj', (root) => {
  //       var boundingBox = new THREE.Box3().setFromObject( root );
  //       boundingBox.getCenter( root.position ).negate();

  //       scene.add(root);
  //     });
  //   });
  // }

  { // load gltf
      const gltfLoader = new GLTFLoader();
      gltfLoader.load('./models/trackbot_room.gltf', (gltf) => {
        const root = gltf.scene;
        scene.add(root);
        //console.log(dumpObject(root).join('\n'));
      });
  }

  function resizeRendererToDisplaySize(renderer) {
    const canvas = renderer.domElement;
    const width = canvas.clientWidth;
    const height = canvas.clientHeight;
    const needResize = canvas.width !== width || canvas.height !== height;
    if (needResize) {
      renderer.setSize(width, height, false);
    }
    return needResize;
  }

  function render() {

    if (resizeRendererToDisplaySize(renderer)) {
      const canvas = renderer.domElement;
      camera.aspect = canvas.clientWidth / canvas.clientHeight;
      camera.updateProjectionMatrix();
    }

    renderer.render(scene, camera);

    requestAnimationFrame(render);
  }

  requestAnimationFrame(render);
}

main();
// init();
// animate();

</script>



</body>
</html>